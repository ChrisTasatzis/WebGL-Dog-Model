<!DOCTYPE HTML>
<html>
	<head>
		<script src="webgl-debug.js"></script>
		<script src="gl-matrix-min.js"></script>
		<!-- Create and Initialize vertex shader -->
		<script id="vShader" type="x-shader/x-vertex">
			// Inputs of vertex shared
			attribute vec4 aVertexPosition; // Input position
			attribute vec4 aVertexColor; // Input color
			
			// Vertices positional bias 
			uniform mat4 uTransformMatrix; 
			
			// Camera perspective 
			uniform mat4 uPerspectiveViewMatrix;	
			
			// color output
			varying vec4 vColor; 
			
			void main() 
			{
				// Generate postion from positional bias and camera perspective 
				gl_Position = uPerspectiveViewMatrix * uTransformMatrix * aVertexPosition; 
				
				// Set the colour of the vertex to be sent to the fshader
				vColor = aVertexColor;  
			} 
		</script>
		
		<script id="fShader" type="x-shader/x-fragment">
			precision mediump float; 

			// Input vertex color from vertex shader 
			varying vec4 vColor; 

			void main() 
			{
				// Set the color of the vertex 
				gl_FragColor = vColor;
			}
		</script>

		<script>
			// Initialize the needed variables 
			var gl; 
			var canvas;
			var shaderProgram; 
			var vertexBuffer; 
			var colorBuffer; 
			var indexBuffer; 
			var vertexPositionAttributePointer;
			var vertexColorAttributePointer;
			var perspectiveViewUniformPointer;
			var transformUniformPointer;





			// BHMA 0.3. Έχει δηλωθεί μία νέα global μεταβλητή για την αποθήκευση της διεύθυνσης του νέου uniform 
		



			var requestId=0; 

			// Creates a WebGL context
			function createGLContext(canvas) 
			{
				var context = null;

				// Get context
				context = canvas.getContext("webgl");  
				if (!context)
					context = canvas.getContext("experimental-webgl"); 
				if (context) {
					// Set size
					context.viewportWidth = canvas.width; 
					context.viewportHeight = canvas.height; 
				} 
				else {
					alert("Failed to create WebGL context!");
				}
				return context;
			}


			// Load a shader from it's script
			function loadShader(type, shaderSource) 
			{
				// Create shader from given script 
				var shader = gl.createShader(type); 
				gl.shaderSource(shader, shaderSource); 
				gl.compileShader(shader); 

				// Check for errors
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { 
					alert("Error compiling shader" + gl.getShaderInfoLog(shader)); 
					gl.deleteShader(shader);  
					return null;
				}

				// Return the shader
				return shader;  
			}

			// Creates the shaders
			function setupShaders() 
			{
				// Get the shader script from DOM
				var vertexShaderSource = document.getElementById("vShader").textContent; 
				var fragmentShaderSource = document.getElementById("fShader").textContent; 
				
				// Load the shaders
				var vertexShader = loadShader(gl.VERTEX_SHADER, vertexShaderSource); 
				var fragmentShader = loadShader(gl.FRAGMENT_SHADER, fragmentShaderSource); 

				// Create a programm and attach the shaders to it 
				shaderProgram = gl.createProgram(); 
				gl.attachShader(shaderProgram, vertexShader); 
				gl.attachShader(shaderProgram, fragmentShader); 
				gl.linkProgram(shaderProgram); 

				// Check for errors
				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
					alert("Failed to setup shaders");
				}

				gl.useProgram(shaderProgram); 

				// Get pointers to the vertex postion and color inputs of vShader
				vertexPositionAttributePointer = gl.getAttribLocation(shaderProgram, "aVertexPosition"); 
				vertexColorAttributePointer = gl.getAttribLocation(shaderProgram, "aVertexColor"); 

				// Enable the inputs of the vShader
				gl.enableVertexAttribArray(vertexPositionAttributePointer); 
				gl.enableVertexAttribArray(vertexColorAttributePointer);
				
				// Get pointers to the tranform and perpective uniforms
				transformUniformPointer = gl.getUniformLocation(shaderProgram, "uTransformMatrix"); 
				perspectiveViewUniformPointer = gl.getUniformLocation(shaderProgram, "uPerspectiveViewMatrix");
			}

			// Creates the buffers for the shapes to de drawn
			function setupBuffers() 
			{

				// Create the vertex buffer for the box element
				vertexBuffer = gl.createBuffer(); 
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); 

				// Setup the vertices for the corners of the box
				var BoxVertices = 
				[
					// Left
					-1.0, -1.0, 1.0, 1.0,
					-1.0, -1.0, -1.0, 1.0,
					-1.0, 1.0, 1.0, 1.0,
					-1.0, 1.0, -1.0, 1.0,

					// Top
					-1.0, 1.0, -1.0, 1.0,
					-1.0, 1.0, 1.0, 1.0,
					1.0, 1.0, -1.0, 1.0,
					1.0, 1.0, 1.0, 1.0,				

					// Right
					1.0, -1.0, -1.0, 1.0,
					1.0, -1.0, 1.0, 1.0,
					1.0, 1.0, -1.0, 1.0,
					1.0, 1.0, 1.0, 1.0,
		
					// Bottom
					-1.0, -1.0, -1.0, 1.0,
					-1.0, -1.0, 1.0, 1.0,
					1.0, -1.0, -1.0, 1.0,
					1.0, -1.0, 1.0, 1.0,				

					// Back
					-1.0, -1.0, -1.0, 1.0,
					-1.0, 1.0, -1.0, 1.0,
					1.0, -1.0, -1.0, 1.0,
					1.0, 1.0, -1.0, 1.0,

					// Front
					-1.0, -1.0, 1.0, 1.0,
					-1.0, 1.0, 1.0, 1.0,
					1.0, -1.0, 1.0, 1.0,
					1.0, 1.0, 1.0, 1.0,
				];

				// Load the buffer with the above data 
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(BoxVertices),	gl.STATIC_DRAW);
				vertexBuffer.itemSize = 4; 
				vertexBuffer.numberOfItems = 24; 

				// Create the color buffer
				colorBuffer=gl.createBuffer(); 
				gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);

				// Setup the color for each of the above corners 
				var colorVertices = 
				[
					// Left
					0.05, 0.25, 0.07, 1,
					0.05, 0.25, 0.07, 1,
					0.05, 0.25, 0.07, 1,
					0.05, 0.25, 0.07, 1,

					// Top
					0.07, 0.35, 0.1, 1,
					0.07, 0.35, 0.1, 1,
					0.07, 0.35, 0.1, 1,
					0.07, 0.35, 0.1, 1,

					// Right
					0.09, 0.45, 0.13, 1,
					0.09, 0.45, 0.13, 1,
					0.09, 0.45, 0.13, 1,
					0.09, 0.45, 0.13, 1,

					// Bottom
					0.11, 0.55, 0.15, 1,
					0.11, 0.55, 0.15, 1,
					0.11, 0.55, 0.15, 1,
					0.11, 0.55, 0.15, 1,

					// Back
					0.13, 0.65, 0.18, 1,
					0.13, 0.65, 0.18, 1,
					0.13, 0.65, 0.18, 1,
					0.13, 0.65, 0.18, 1,

					// Front
					0.17, 0.85, 0.24, 1,
					0.17, 0.85, 0.24, 1,
					0.17, 0.85, 0.24, 1,
					0.17, 0.85, 0.24, 1,
				];

				// Load the buffer with the above data 					
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorVertices),	gl.STATIC_DRAW);
				colorBuffer.itemSize=4;
				colorBuffer.numberOfItems=24;

				// Create a buffer for the triangles
				indexBuffer = gl.createBuffer(); 
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer); 

				// Setup the buffer with the 12 triangles needed (2 for each side)
				var indexMatrix = 
				[
					// Left
					0, 1, 2,
					1, 2, 3,

					// Top
					4, 5, 6,
					5, 6, 7,

					// Right
					8, 9, 10,
					9, 10, 11,

					// Bottom
					12, 13, 14,
					13, 14, 15,

					// Back
					16, 17, 18,
					17, 18, 19,

					// Front
					20, 21, 22,
					21, 22, 23
				];

				// Load the buffer with the above data 					
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(indexMatrix),gl.STATIC_DRAW);   
				indexBuffer.itemSize=1; 
				indexBuffer.numberOfItems = 36;  
			}

			function redraw() 
			{	
				// Create the view, perpective and combined matrices
				var vMatrix = mat4.create();
				var pMatrix = mat4.create();
				var pvMatrix = mat4.create();
				
				// Set the the distance of the camera 
				var r = 2;

				// Create the position of the camera
				var pos = [r, r, r];

				// Set where the camera is looking 
				var view = [0, 0, 0];

				// Set the top side view to be on the positive side of the Y axis
				var top = [0, 1, 0];

				// Fill the view matrix with the right values 
				mat4.lookAt(vMatrix, pos, view, top);
					
				// Fill the view perspective with the right values  (angle, dimension ratio, closest threshold, farthest threshold)				
				mat4.perspective(pMatrix, Math.PI/2, 1, 0.01, 20);
				
				// Get the combined perspective and view matrix
				mat4.multiply(pvMatrix, pMatrix, vMatrix);
					
				// Push the pvMatrix to the right uniform pointer 
				gl.uniformMatrix4fv(perspectiveViewUniformPointer, false, new Float32Array(pvMatrix));
				
				// Clear the buffers
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				// Push the buffers to the vertex shader
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
				gl.vertexAttribPointer(vertexPositionAttributePointer, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
				gl.vertexAttribPointer(vertexColorAttributePointer, colorBuffer.itemSize, gl.FLOAT, false, 0, 0); 
				
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer); 

				// Create a cube object at the center 
				var temp=mat4.create();
				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(temp)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);				
			}

			function startup() {
				// Get canvas from DOM
				canvas = document.getElementById("myGLCanvas"); 
			
				// Get dimensions of the window
				var minDimension=Math.min(window.innerWidth,window.innerHeight); 

				// Set the dimensions of the canvas
				canvas.width=0.9*minDimension; 
				canvas.height=0.9*minDimension; 

				// Populate canvas with WebGL context
				gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas)); 

				// Create shaders and buffers 
				setupShaders(); 
				setupBuffers(); 

				// Set the background color
				gl.clearColor(0, 0.2, 0.4, 1.0); 
				
				// Enable the WebGL context
				gl.enable(gl.DEPTH_TEST); 

				// Resizing WebGL context according to canvas size
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			
				// Clear WebGL context 
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 	

				// Draw the first scene
				redraw(); 
			}

			function startAnim() 
			{
				if (!requestId)
					anim();
			}

			function anim() 
			{
				requestId = window.requestAnimationFrame(anim);
				redraw();
			}

			function stopAnim() 
			{
				window.cancelAnimationFrame(requestId);
				requestId = 0;
			}
		</script>
	</head>

	<body onload="startup()">
		<canvas id="myGLCanvas" >
		</canvas>
		<p>
		Rotate by:<input type="text" id="angleText" value="1">
		Camera Height by:<input type="text" id="ZText" value="0.01">
		<button onClick=startAnim()>Start</button>
		<button onClick=stopAnim()>Stop</button>
		</p>
	</body>
</html>
<!DOCTYPE HTML>
<html>
	<head>
		<script src="webgl-debug.js"></script>
		<script src="gl-matrix-min.js"></script>
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
		<!-- Create and Initialize vertex shader -->
		<script id="vShader" type="x-shader/x-vertex">
			// Inputs of vertex shader
			attribute vec4 aVertexPosition; // Input position
			attribute vec4 aVertexColor; // Input color
			attribute vec2 aTextureCoordinates; // Input texture

			// Vertices positional bias 
			uniform mat4 uTransformMatrix; 
			
			// Camera perspective 
			uniform mat4 uPerspectiveViewMatrix;	
			
			// Texture output 
			varying vec2 vTextureCoordinates;

			void main() 
			{
				// Generate postion from positional bias and camera perspective 
				gl_Position = uPerspectiveViewMatrix * uTransformMatrix * aVertexPosition; 
				
				// Set the the texture coordinates
				vTextureCoordinates = aTextureCoordinates;    
			} 
		</script>
		
		<script id="fShader" type="x-shader/x-fragment">
			precision mediump float; 

			// Input vertex texture from vertex shader
			varying vec2 vTextureCoordinates;

			// Create a uniform for the texture
			uniform sampler2D uSampler;

			void main() 
			{
				// Set the color of the vertex according to the texture
				gl_FragColor = texture2D(uSampler, vTextureCoordinates);
			}
		</script>

		<script>
			// Initialize the needed variables 
			var gl; 
			var canvas;
			var shaderProgram; 
			var vertexBuffer; 
			var colorBuffer; 
			var indexBuffer;
			var textureBuffer; 
			var vertexPositionAttributePointer;
			var vertexColorAttributePointer;
			var perspectiveViewUniformPointer;
			var textureCoordinatesAttributePointer;
			var transformUniformPointer;
			var requestId = 0; 
			var totalCamRot = -Math.PI/4;
			var totalHeight = 20;
			var camDistance = 20;
			var bodyTexture;
			var skyTexture;
			var floorVBuffer;
			var floorIBuffer;
			var mouseDown = false; // flag ότι κουμπί του ποντικιού είναι πατημένο
			var deltaFresh = false; // όταν κρατάμε πατημένο το κουμπί στο animation, το deltaX, deltaY χρησιμοποιούνται επανειλημένα // αυτό το flag θα το εμποδίζει αυτό
			var lastMouseX = null; // Τελευταία καταγεγεραμμένη θέση ποντικιού στον καμβά
			var lastMouseY = null; 
			var currMouseX = null; // Τρέχουσα θέση ποντικιού στον καμβά
			var currMouseY = null;
			var deltaMouseX = 0; // Διαφορά τρέχουσας - τελευταίας καταγεγραμμένης θέσης
			var deltaMouseY = 0;
			var mouseSensitivityX = 1/5000;
			var mouseSensitivityY = 1/500;
			var mainAnimation = false;

			var headAnimZ = 0;
			var headAnimStep = 0.05;
			var headAnimDirection = 1;

			var tailAnimX = 0;
			var tailAnimStep = 0.05;
			var tailAnimDirection = 1;

			var FLPAnimY = 0;
			var FLPAnimStep = 0.05;
			var FLPAnimDirection = 1;

			var FRPAnimY = 0;
			var FRPAnimStep = 0.05;
			var FRPAnimDirection = 1;

			var playDeadAnimX = 0;
			var playDeadAnimStep = 0.05;
			var playDeadAnimDirection = 1;

			var staticWalkAnimY = 0;
			var staticWalkAnimStep = 0.05;
			var staticWalkAnimDirection = 1;

			var normalWalkAnimY = 0;
			var normalWalkAnimStep = 0.05;
			var normalWalkAnimDirection = 1;

			var dachsHundAnimLength = 14;
			var dachsHundAnimStep = 0.05;
			var dachsHundAnimDirection = 1;
			var dachsHundAnimScale = 1;

			var cartoonAnimPawStep = 0.03;
			var cartoonAnimPawScale = 1;
			var cartoonAnimPawLength = 5;
			var cartoonAnimPawDirection = 1;
			var cartoonAnimTailAngle = 0;
			var cartoonAnimTailStep = 0.1;
			var cartoonNeckLength = 3;
			var cartoonAnimNeckDirection = 1;
			var cartoonNeckStep = 0.05;
			var cartoonNeckScale = 1;


			function loadImageForTexture(url, textureObject) {
				// 	Create a new image object
				var image = new Image();

				// Do the below when the image loads
				image.onload = function() 
				{    
					// Activate given texture as current
					gl.bindTexture(gl.TEXTURE_2D, textureObject);

					// Invert Y
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

					// Copy image on activated texture
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

					// Determine how new pixels are generated (if needed)
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

					// Determine how the pixels will be merged (if needed)
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
					
					// Generate MipMap
					gl.generateMipmap(gl.TEXTURE_2D);				
				}
					
				// Load image
				image.src = url;
			}

			// Creates a WebGL context
			function createGLContext(canvas) 
			{
				var context = null;

				// Get context
				context = canvas.getContext("webgl");  
				if (!context)
					context = canvas.getContext("experimental-webgl"); 
				if (context) {
					// Set size
					context.viewportWidth = canvas.width; 
					context.viewportHeight = canvas.height; 
				} 
				else {
					alert("Failed to create WebGL context!");
				}
				return context;
			}


			// Load a shader from it's script
			function loadShader(type, shaderSource) 
			{
				// Create shader from given script 
				var shader = gl.createShader(type); 
				gl.shaderSource(shader, shaderSource); 
				gl.compileShader(shader); 

				// Check for errors
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { 
					alert("Error compiling shader" + gl.getShaderInfoLog(shader)); 
					gl.deleteShader(shader);  
					return null;
				}

				// Return the shader
				return shader;  
			}

			// Creates the shaders
			function setupShaders() 
			{
				// Get the shader script from DOM
				var vertexShaderSource = document.getElementById("vShader").textContent; 
				var fragmentShaderSource = document.getElementById("fShader").textContent; 
				
				// Load the shaders
				var vertexShader = loadShader(gl.VERTEX_SHADER, vertexShaderSource); 
				var fragmentShader = loadShader(gl.FRAGMENT_SHADER, fragmentShaderSource); 

				// Create a programm and attach the shaders to it 
				shaderProgram = gl.createProgram(); 
				gl.attachShader(shaderProgram, vertexShader); 
				gl.attachShader(shaderProgram, fragmentShader); 
				gl.linkProgram(shaderProgram); 

				// Check for errors
				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
					alert("Failed to setup shaders");
				}

				gl.useProgram(shaderProgram); 

				// Get pointers to the vertex postion and texture color inputs of vShader
				vertexPositionAttributePointer = gl.getAttribLocation(shaderProgram, "aVertexPosition"); 
				textureCoordinatesAttributePointer = gl.getAttribLocation(shaderProgram, "aTextureCoordinates");

				// Enable the inputs of the vShader
				gl.enableVertexAttribArray(vertexPositionAttributePointer); 
				gl.enableVertexAttribArray(textureCoordinatesAttributePointer);
				
				// Get pointers to the tranform and perpective uniforms
				transformUniformPointer = gl.getUniformLocation(shaderProgram, "uTransformMatrix"); 
				perspectiveViewUniformPointer = gl.getUniformLocation(shaderProgram, "uPerspectiveViewMatrix");

				// Get pointer to the sampler uniform 
				samplerUniformPointer = gl.getUniformLocation(shaderProgram, "uSampler");
			}

			// Creates the buffers for the shapes to de drawn
			function setupBuffers() 
			{
				// Create the vertex buffer for the box element
				vertexBuffer = gl.createBuffer(); 
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); 

				// Setup the vertices for the corners of the box
				var BoxVertices = 
				[
					// Back
					-1.0, -1.0, 1.0, 1.0,
					-1.0, -1.0, -1.0, 1.0,
					-1.0, 1.0, 1.0, 1.0,
					-1.0, 1.0, -1.0, 1.0,

					// Left
					-1.0, 1.0, -1.0, 1.0,
					-1.0, 1.0, 1.0, 1.0,
					1.0, 1.0, -1.0, 1.0,
					1.0, 1.0, 1.0, 1.0,				

					// Front
					1.0, -1.0, -1.0, 1.0,
					1.0, -1.0, 1.0, 1.0,
					1.0, 1.0, -1.0, 1.0,
					1.0, 1.0, 1.0, 1.0,
		
					// Right
					-1.0, -1.0, -1.0, 1.0,
					-1.0, -1.0, 1.0, 1.0,
					1.0, -1.0, -1.0, 1.0,
					1.0, -1.0, 1.0, 1.0,				

					// Bottom
					-1.0, -1.0, -1.0, 1.0,
					-1.0, 1.0, -1.0, 1.0,
					1.0, -1.0, -1.0, 1.0,
					1.0, 1.0, -1.0, 1.0,

					// Top
					-1.0, -1.0, 1.0, 1.0,
					-1.0, 1.0, 1.0, 1.0,
					1.0, -1.0, 1.0, 1.0,
					1.0, 1.0, 1.0, 1.0,
				];

				// Load the buffer with the above data 
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(BoxVertices),	gl.STATIC_DRAW);
				vertexBuffer.itemSize = 4; 
				vertexBuffer.numberOfItems = 24; 

				// Create a buffer for the triangles
				indexBuffer = gl.createBuffer(); 
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer); 

				// Setup the buffer with the 12 triangles needed (2 for each side)
				var indexMatrix = 
				[
					// Back
					0, 1, 2,
					1, 2, 3,

					// Left
					4, 5, 6,
					5, 6, 7,

					// Front
					8, 9, 10,
					9, 10, 11,

					// Right
					12, 13, 14,
					13, 14, 15,

					// Bottom
					16, 17, 18,
					17, 18, 19,

					// Top
					20, 21, 22,
					21, 22, 23
				];
				
				// Load the buffer with the above data 					
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(indexMatrix),gl.STATIC_DRAW);   
				indexBuffer.itemSize=1; 
				indexBuffer.numberOfItems = 36;

				// Create the vertex buffer for the floor element
				floorVBuffer = gl.createBuffer(); 
				gl.bindBuffer(gl.ARRAY_BUFFER, floorVBuffer); 

				// Setup the vertices for the four corners of the square
				var floorVertices = 
				[
					-12.5, -12.5, 0.0, 1.0,
					-12.5, 12.5, 0.0, 1.0,
					12.5, -12.5, 0.0, 1.0,
					12.5, 12.5, 0.0, 1.0
				];

				// Load the buffer with the above data 
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floorVertices),	gl.STATIC_DRAW);
				floorVBuffer.itemSize = 4; 
				floorVBuffer.numberOfItems = 4; 

				// Create the buffer for the triangles
				floorIBuffer = gl.createBuffer(); 
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,floorIBuffer); 

				// Setup the buffer with the 2 triangles needed (1 square)
				var floorIndexMatrix = 
				[
					0, 1, 2,
					1, 2, 3
				];
				
				// Load the buffer with the above data 					
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(floorIndexMatrix),gl.STATIC_DRAW);   
				floorIBuffer.itemSize=1; 
				floorIBuffer.numberOfItems = 6 ;

				// Create the texture buffer
				textureBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);

				// Each face of the cube get the whole image as a texture
				var textureCoordinates=[
					// Back
					0.0, 0.0,
					0.0, 1.0,
					1.0, 0.0,
					1.0, 1.0,

					// Left
					0.0, 0.0,
					0.0, 1.0,
					1.0, 0.0,
					1.0, 1.0,	

					// Front
					0.0, 0.0,
					0.0, 1.0,
					1.0, 0.0,
					1.0, 1.0,
		
					// Right
					0.0, 0.0,
					0.0, 1.0,
					1.0, 0.0,
					1.0, 1.0,			

					// Bottom
					0.0, 0.0,
					0.0, 1.0,
					1.0, 0.0,
					1.0, 1.0,

					// Top
					0.0, 0.0,
					0.0, 1.0,
					1.0, 0.0,
					1.0, 1.0,
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),gl.STATIC_DRAW);  
				textureBuffer.itemSize = 2;
				textureBuffer.numberOfItems = 24;

				// Create the texture buffer for the head
				headTextureBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, headTextureBuffer);
				
				// The faces get the right portion of the texture image
				var headTextureCoordinates=[
					// Back
					0.0, 1.0,
					0.0, 0.5,
					0.5, 0.5,
					0.5, 1.0,

					// Left
					0.0, 1.0,
					0.0, 0.5,
					0.5, 0.5,
					0.5, 1.0,

					// Front
					0.0, 0.0,
					0.0, 0.5,
					0.65, 0.0,
					0.65, 0.5,
		
					// Right
					0.0, 1.0,
					0.0, 0.5,
					0.5, 0.5,
					0.5, 1.0,		

					// Bottom
					0.0, 1.0,
					0.0, 0.5,
					0.5, 0.5,
					0.5, 1.0,

					// Top
					1.0, 0.5,
					1.0, 1.0,
					0.5, 0.5,
					0.5, 1.0
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(headTextureCoordinates),gl.STATIC_DRAW);  
				headTextureBuffer.itemSize = 2;
				headTextureBuffer.numberOfItems = 24;

				// Create floor texture buffer
				floorTextureBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, floorTextureBuffer);
				var floorTextureCoordinates=[
					0.0, 0.0,
					0.0, 1.0,
					1.0, 0.0,
					1.0, 1.0
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floorTextureCoordinates),gl.STATIC_DRAW);  
				floorTextureBuffer.itemSize = 2;
				floorTextureBuffer.numberOfItems = 4;

				// Load body texture
				bodyTexture = gl.createTexture();
				var bodyTextureUrl = "body-texture.png";
				loadImageForTexture(bodyTextureUrl, bodyTexture);

				// Load sky texture
				skyTexture = gl.createTexture();
				var skyTextureUrl = "sky-texture.jpg";
				loadImageForTexture(skyTextureUrl, skyTexture);

				// Load floor texture
				floorTexture = gl.createTexture();
				var floorTextureUrl = "floor-texture.jpg";
				loadImageForTexture(floorTextureUrl, floorTexture);

				// Load head texture
				headTexture = gl.createTexture();
				var headTextureUrl = "head-texture.png";
				loadImageForTexture(headTextureUrl, headTexture);

			}

			function redraw() 
			{	
				// Get the user inputs
				var camAngle = parseFloat(document.getElementById('cAngle').value);
				var isHead = document.getElementById('Head').checked;
				var isFLPaw = document.getElementById('FrontLeftPaw').checked;
				var isFRPaw = document.getElementById('FrontLeftPaw').checked;
				var isTail = document.getElementById('Tail').checked;

				// Calculate the camera angle from degrees to rad and prevent overflow
				camAngle = (camAngle%360)*Math.PI/180.0;

				// If mouse is clicked
				if(mouseDown && deltaFresh)
				{
					camRot= -deltaMouseX * mouseSensitivityX;
					camHeight= -deltaMouseY * mouseSensitivityY;
					deltaFresh = false;
				}
				else 
				{
					camRot=0;
					camHeight=0;
				}

				
				// Calculate the total camera rotation
				totalCamRot = (totalCamRot + camRot)%(2*Math.PI);
				
				// Calculate the total camera height
				totalHeight = totalHeight + camHeight;
				 
				// Create the view, perpective and combined matrices
				var vMatrix = mat4.create();
				var pMatrix = mat4.create();
				var pvMatrix = mat4.create();
				
				// Create the position of the camera
				var pos = [camDistance * Math.cos(totalCamRot), camDistance * Math.sin(totalCamRot), totalHeight];

				// Set where the camera is looking 
				var view = [0, 0, 0];

				// Set the top side view to be on the positive side of the Z axis
				var top = [0, 0, 1];

				// Fill the view matrix with the right values 
				mat4.lookAt(vMatrix, pos, view, top);
					
				// Fill the view perspective with the right values  (angle, dimension ratio, closest threshold, farthest threshold)				
				mat4.perspective(pMatrix, camAngle, 1, 0.001, 10000);
				
				// Get the combined perspective and view matrix
				mat4.multiply(pvMatrix, pMatrix, vMatrix);
					
				// Push the pvMatrix to the right uniform pointer 
				gl.uniformMatrix4fv(perspectiveViewUniformPointer, false, new Float32Array(pvMatrix));
				
				// Clear the buffers
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				// Initialize matrices
				var TranslationMatrix = mat4.create();
				var ScaleMatrix = mat4.create();
				var TrSc = mat4.create();
				

				// Push the buffers for the floor to the vertex shader
				gl.bindBuffer(gl.ARRAY_BUFFER, floorVBuffer);
				gl.vertexAttribPointer(vertexPositionAttributePointer, floorVBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,floorIBuffer); 

				// Activate the floor texture
				gl.activeTexture(gl.TEXTURE0);	

				// Bind texture pointer with the loaded texture
				gl.bindTexture(gl.TEXTURE_2D, floorTexture);
				gl.uniform1i(samplerUniformPointer, 0);
				gl.bindBuffer(gl.ARRAY_BUFFER, floorTextureBuffer);
				gl.vertexAttribPointer(textureCoordinatesAttributePointer, floorTextureBuffer.itemSize, gl.FLOAT, false, 0, 0);

				// Create the floor
				var tmp = mat4.create();
				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(tmp)); 
				gl.drawElements(gl.TRIANGLES,floorIBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Push the box buffers to the vertex shader
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
				gl.vertexAttribPointer(vertexPositionAttributePointer, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer); 
				
				// Activate the skybox texture
				gl.activeTexture(gl.TEXTURE1);

				// Bind texture pointer with the loaded texture
				gl.bindTexture(gl.TEXTURE_2D, skyTexture);
				gl.uniform1i(samplerUniformPointer, 1);
				gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
				gl.vertexAttribPointer(textureCoordinatesAttributePointer, textureBuffer.itemSize, gl.FLOAT, false, 0, 0);

				// Create the skybox
				mat4.fromTranslation(TranslationMatrix, [0, 0, 0]);
				mat4.fromScaling(ScaleMatrix, [2500, 2500, 2500])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Activate the body texture
				gl.activeTexture(gl.TEXTURE2);

				// Bind texture pointer with the loaded texture
				gl.bindTexture(gl.TEXTURE_2D, bodyTexture);
				gl.uniform1i(samplerUniformPointer, 2);
				gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
				gl.vertexAttribPointer(textureCoordinatesAttributePointer, textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				// Create the body parts
				// Body
				mat4.fromTranslation(TranslationMatrix, [-1, 0, 7.5]);
				mat4.fromScaling(ScaleMatrix, [7, 3, 2.5])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation	 for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the normal walk animation
				TrSc = normalWalk(TrSc, true,  1, true);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, false, true);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Neck
				mat4.fromTranslation(TranslationMatrix, [4, 0, 11.5]);
				mat4.fromScaling(ScaleMatrix, [2, 2, 1.5])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation	 for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, true,  1, true);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, true, false);

				// Apply the animation for the cartoon animation
				TrSc = cartoon(TrSc, false, false, 0, 0, true, false);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Left back paw
				mat4.fromTranslation(TranslationMatrix, [-5.5, 4.5, 1]);
				mat4.fromScaling(ScaleMatrix, [2.5, 1.5, 1])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the static walk animation
				TrSc = staticWalk(TrSc, false, -1);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, false, -1, false);
				
				// Apply the animation	 for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, false, false);

				// Apply the animation for the cartoon animation
				TrSc = cartoon(TrSc, false, true, -5.5, 4.5, false, false);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);	

				// Right back paw
				mat4.fromTranslation(TranslationMatrix, [-5.5, -4.5, 1]);
				mat4.fromScaling(ScaleMatrix, [2.5, 1.5, 1])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the static walk animation
				TrSc = staticWalk(TrSc, false, 1);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, false,  1, false);

				// Apply the animation for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, false, false);

				// Apply the animation for the cartoon animation
				TrSc = cartoon(TrSc, false, true, -5.5, -4.5, false, false);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Left front paw
				mat4.fromTranslation(TranslationMatrix, [5.5, 4.5, 1]);
				mat4.fromScaling(ScaleMatrix, [2.5, 1.5, 1])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the static walk animation
				TrSc = staticWalk(TrSc, true, 1);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, true,  1, false);

				// Apply the animation for the left leg
				TrSc = FLPAnimation(TrSc);

				// Apply the animation	 for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, true, false);

				// Apply the animation for the cartoon animation
				TrSc = cartoon(TrSc, false, true, 5.5, 4.5, false, false);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Right front paw
				mat4.fromTranslation(TranslationMatrix, [5.5, -4.5, 1]);
				mat4.fromScaling(ScaleMatrix, [2.5, 1.5, 1])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the right leg
				TrSc = FRPAnimation(TrSc);

				// Apply the animation for the static walk animation
				TrSc = staticWalk(TrSc, true, -1);

				TrSc = normalWalk(TrSc, true, -1, false);

				// Apply the animation for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, true, false);

				// Apply the animation for the cartoon animation
				TrSc = cartoon(TrSc, false, true, 5.5, -4.5, false, false);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Left back leg
				mat4.fromTranslation(TranslationMatrix, [-6.5, 4.5, 5]);
				mat4.fromScaling(ScaleMatrix, [1.5, 1.5, 3])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the static walk animation
				TrSc = staticWalk(TrSc, false, -1);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, false,  -1, false);

				// Apply the animation for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, false, false);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);	

				// Right back leg
				mat4.fromTranslation(TranslationMatrix, [-6.5, -4.5, 5]);
				mat4.fromScaling(ScaleMatrix, [1.5, 1.5, 3])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the static walk animation
				TrSc = staticWalk(TrSc, false, 1);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, false,  1, false);

				// Apply the animation	 for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, false, false);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Left front leg
				mat4.fromTranslation(TranslationMatrix, [4.5, 4.5, 5]);
				mat4.fromScaling(ScaleMatrix, [1.5, 1.5, 3])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the left leg
				TrSc = FLPAnimation(TrSc);

				// Apply the animation for the static walk animation
				TrSc = staticWalk(TrSc, true, 1);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, true,  1, false);

				// Apply the animation	 for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, true, false);				

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Right front leg
				mat4.fromTranslation(TranslationMatrix, [4.5, -4.5, 5]);
				mat4.fromScaling(ScaleMatrix, [1.5, 1.5, 3])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the left leg
				TrSc = FRPAnimation(TrSc);

				// Apply the animation for the static walk animation
				TrSc = staticWalk(TrSc, true, -1);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, true,  -1, false);

				// Apply the animation	 for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, true, false);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Tail
				mat4.fromTranslation(TranslationMatrix, [-9, 0, 10.5]);
				mat4.fromScaling(ScaleMatrix, [1, 1, 2.5])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the tail
				TrSc = tailAnimation(TrSc);

				// Apply the animation	 for the play dead animation
				TrSc = playDead(TrSc);
				
				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, true,  1, true);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, false, false);

				// Apply the animation for the cartoon animation
				TrSc = cartoon(TrSc, true, false, 0, 0, false, false);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);
				
				// Left Ear
				mat4.fromTranslation(TranslationMatrix, [3, 4, 14.5]);
				mat4.fromScaling(ScaleMatrix, [1, 1, 2.5])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the head
				TrSc = headAnimation(TrSc);

				// Apply the animation	 for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the normal walk animation
				TrSc = normalWalk(TrSc, true,  1, true);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, true, false);

				// Apply the animation for the cartoon animation
				TrSc = cartoon(TrSc, false, false, 0, 0, false, true);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Right Ear
				mat4.fromTranslation(TranslationMatrix, [3, -4, 14.5]);
				mat4.fromScaling(ScaleMatrix, [1, 1, 2.5])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the head
				TrSc = headAnimation(TrSc);

				// Apply the animation for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, true,  1, true);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, true, false);

				// Apply the animation for the cartoon animation
				TrSc = cartoon(TrSc, false, false, 0, 0, false, true);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);

				// Activate the texture for the head
				gl.activeTexture(gl.TEXTURE3);

				// Bind texture pointer with the loaded texture
				gl.bindTexture(gl.TEXTURE_2D, headTexture);
				gl.uniform1i(samplerUniformPointer, 3);
				gl.bindBuffer(gl.ARRAY_BUFFER, headTextureBuffer);
				gl.vertexAttribPointer(textureCoordinatesAttributePointer, headTextureBuffer.itemSize, gl.FLOAT, false, 0, 0);

				// Create the head
				mat4.fromTranslation(TranslationMatrix, [6, 0, 15]);
				mat4.fromScaling(ScaleMatrix, [4, 3, 2])
				mat4.multiply(TrSc, TranslationMatrix, ScaleMatrix);

				// Apply the animation for the head
				TrSc = headAnimation(TrSc);

				// Apply the animation for the play dead animation
				TrSc = playDead(TrSc);

				// Apply the animation for the normal; walk animation
				TrSc = normalWalk(TrSc, true,  1, true);

				// Apply the animation for the dachsHund animation
				TrSc = dachsHund(TrSc, true, false);

				// Apply the animation for the cartoon animation
				TrSc = cartoon(TrSc, false, false, 0, 0, false, true);

				gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(TrSc)); 
				gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);
				

			}

			function startup() {
				// Get canvas from DOM
				canvas = document.getElementById("myGLCanvas"); 
			
				// Get dimensions of the window
				var minDimension=Math.min(window.innerWidth,window.innerHeight); 

				// Set the dimensions of the canvas
				canvas.width=0.9*minDimension; 
				canvas.height=0.9*minDimension; 

				// Populate canvas with WebGL context
				gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas)); 

				// Create shaders and buffers 
				setupShaders(); 
				setupBuffers(); 

				// Set the background color
				gl.clearColor(0, 0.2, 0.4, 1.0); 
				
				// Enable the WebGL context
				gl.enable(gl.DEPTH_TEST); 

				// Resizing WebGL context according to canvas size
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			
				// Clear WebGL context 
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 	

				// Set actions for mouse control
				canvas.onwheel = handleMouseWheel;
				canvas.onmousedown = handleMouseDown;
				window.onmouseup = handleMouseUp;
				canvas.onmousemove = handleMouseMove;

				// Get the rectangle of the canvas to get its location in the window
				rect = canvas.getBoundingClientRect();

				// Draw the first scene
				startAnim(); 
			}

			function handleMouseWheel(event) 
			{
				var isCamera = document.getElementById('cHeight').checked;
				
				if(isCamera)
				{
					// Change camera distance accordingly
					if (event.deltaY > 0 && camDistance <= 10000)
						camDistance = camDistance*1.03;
					else if(event.deltaY < 0 && camDistance >= 0.001)
						camDistance = camDistance*0.97;
				}

				handleSimpleAnimations();

				if(!mainAnimation)
					handleMainAnimations();

				// Redraw frame
				if(!requestId) 
					redraw();
			}


			function handleMouseMove(event) 
			{
				// Calculate current mouse position in the canvas
				currMouseX = event.clientX - rect.left;
				currMouseY = rect.bottom - event.clientY;

				// Calculate mouse movement while clicked 
				if (mouseDown)
				{
					if(currMouseX != lastMouseX || currMouseY != lastMouseY)
					{
						deltaMouseX = currMouseX - lastMouseX;
						deltaMouseY = currMouseY - lastMouseY;
					}
					else
					{
						deltaMouseX = lastMouseX;
						deltaMouseY = lastMouseY;
					}
			
					deltaFresh = true;
				}
			}	

			function handleMouseDown(event) 
			{
				// Register mouse click 
				mouseDown = true;

				// Keep the last position of the mouse when not clicked
				lastMouseX = event.clientX - rect.left;
				lastMouseY = rect.bottom - event.clientY;

				// Set mouse distances to 0 
				deltaMouseX = 0;
				deltaMouseY = 0;

				deltaFresh = true;
			}

			function headAnimation(part)
			{
				var HeadAnimRotationMatrix = mat4.create();
				var tmp = mat4.create();

				// Translate the part to the right position 
				mat4.fromTranslation(tmp, [-4, 0, 0])
				mat4.multiply(part, tmp, part)

				// Calculate Rotation for the animation  and rotate the part
				mat4.fromRotation(HeadAnimRotationMatrix, headAnimZ, [0, 0, 1]);
				mat4.multiply(part, HeadAnimRotationMatrix, part)

				// Translate part to iniital position
				mat4.fromTranslation(tmp, [4, 0, 0])
				mat4.multiply(part, tmp, part)

				return part;
			}

			function FLPAnimation(part)
			{
				var FLPAnimRotationMatrix = mat4.create();
				var tmp = mat4.create();

				// Translate the part to the right position 
				mat4.fromTranslation(tmp, [-5.5, 0, -6.5])
				mat4.multiply(part, tmp, part)

				// Calculate Rotation for the animation  and rotate the part
				mat4.fromRotation(FLPAnimRotationMatrix, FLPAnimY, [0, 1, 0]);
				mat4.multiply(part, FLPAnimRotationMatrix, part)

				// Translate part to iniital position
				mat4.fromTranslation(tmp, [5.5, 0, 6.5])
				mat4.multiply(part, tmp, part)

				return part;
			}

			function FRPAnimation(part)
			{
				var FRPAnimRotationMatrix = mat4.create();
				var tmp = mat4.create();

				// Translate the part to the right position 
				mat4.fromTranslation(tmp, [-5.5, 0, -6.5])
				mat4.multiply(part, tmp, part)

				// Calculate Rotation for the animation  and rotate the part
				mat4.fromRotation(FRPAnimRotationMatrix, FRPAnimY, [0, 1, 0]);
				mat4.multiply(part, FRPAnimRotationMatrix, part)

				// Translate part to iniital position
				mat4.fromTranslation(tmp, [5.5, 0, 6.5])
				mat4.multiply(part, tmp, part)

				return part;
			}

			function tailAnimation(part)
			{
				var tailAnimRotationMatrix = mat4.create();
				var tmp = mat4.create();

				// Translate the part to the right position 
				mat4.fromTranslation(tmp, [0, 0, -9])
				mat4.multiply(part, tmp, part)

				// Calculate Rotation for the animation  and rotate the part
				mat4.fromRotation(tailAnimRotationMatrix, tailAnimX, [1, 0, 0]);
				mat4.multiply(part, tailAnimRotationMatrix, part)

				// Translate part to iniital position
				mat4.fromTranslation(tmp, [0, 0, 9])
				mat4.multiply(part, tmp, part)

				return part;
			}

			function playDead(part)
			{
				var tailAnimRotationMatrix = mat4.create();
				var tmp = mat4.create();

				// Translate the part to the right position 
				mat4.fromTranslation(tmp, [0, -6, 0])
				mat4.multiply(part, tmp, part)

				// Calculate Rotation for the animation  and rotate the part
				mat4.fromRotation(tailAnimRotationMatrix, playDeadAnimX, [1, 0, 0]);
				mat4.multiply(part, tailAnimRotationMatrix, part)

				// Translate part to iniital position
				mat4.fromTranslation(tmp, [0, 6, 0])
				mat4.multiply(part, tmp, part)

				return part;
			}

			function staticWalk(part, isfront, direction)
			{
				var staticWalkAnimRotationMatrix = mat4.create();
				var tmp = mat4.create();

				if(isfront)
				{
					// Translate the part to the right position 
					mat4.fromTranslation(tmp, [-4.5, 0, -6.5])
					mat4.multiply(part, tmp, part)

					// Calculate Rotation for the animation  and rotate the part
					mat4.fromRotation(staticWalkAnimRotationMatrix, direction*staticWalkAnimY, [0, 1, 0]);
					mat4.multiply(part, staticWalkAnimRotationMatrix, part)

					// Translate part to iniital position
					mat4.fromTranslation(tmp, [4.5, 0, 6.5])
					mat4.multiply(part, tmp, part)
				}
				else
				{
					// Translate the part to the right position 
					mat4.fromTranslation(tmp, [6.5, 0, -6.5])
					mat4.multiply(part, tmp, part)

					// Calculate Rotation for the animation  and rotate the part
					mat4.fromRotation(staticWalkAnimRotationMatrix, direction*staticWalkAnimY, [0, 1, 0]);
					mat4.multiply(part, staticWalkAnimRotationMatrix, part)

					// Translate part to iniital position
					mat4.fromTranslation(tmp, [-6.5, 0, 6.5])
					mat4.multiply(part, tmp, part)
				}
				return part;
			}

			function normalWalk(part, isFront, direction, isBody)
			{
				var normalWalkAnimRotationMatrix = mat4.create();
				var tmp = mat4.create();

				if(isFront && !isBody)
				{
					// Translate the part to the right position 
					mat4.fromTranslation(tmp, [-4.5, 0, -6.5]);
					mat4.multiply(part, tmp, part);

					// Calculate Rotation for the animation  and rotate the part
					mat4.fromRotation(normalWalkAnimRotationMatrix, direction*normalWalkAnimY, [0, 1, 0]);
					mat4.multiply(part, normalWalkAnimRotationMatrix, part);

					// Translate part to iniital position
					mat4.fromTranslation(tmp, [4.5+3*normalWalkAnimY, 0, 6.5]);
					mat4.multiply(part, tmp, part);
				}
				else if (!isFront && !isBody)
				{
					// Translate the part to the right position 
					mat4.fromTranslation(tmp, [6.5, 0, -6.5]);
					mat4.multiply(part, tmp, part);

					// Calculate Rotation for the animation  and rotate the part
					mat4.fromRotation(normalWalkAnimRotationMatrix, direction*normalWalkAnimY, [0, 1, 0]);
					mat4.multiply(part, normalWalkAnimRotationMatrix, part)

					// Translate part to iniital position
					mat4.fromTranslation(tmp, [-6.5+3*normalWalkAnimY, 0, 6.5]);
					mat4.multiply(part, tmp, part)
				}
				else
				{					
					// Translate part to iniital position
					mat4.fromTranslation(tmp, [3*normalWalkAnimY, 0, 0]);
					mat4.multiply(part, tmp, part)
				}

				return part;
			}

			function dachsHund(part, isFront, isBody)
			{
				var tmp = mat4.create();
				var tmp2 = mat4.create();

				if(isBody)
				{
					mat4.fromTranslation(tmp2, [1, 0, 0])
					mat4.multiply(part, tmp2, part);
					mat4.fromScaling(tmp, [dachsHundAnimScale, 1, 1]);
					mat4.multiply(part, tmp, part);
					mat4.fromTranslation(tmp2, [-1, 0, 0])
					mat4.multiply(part, tmp2, part);
					return part;
				}

				if(isFront)
				{
					mat4.fromTranslation(tmp, [dachsHundAnimLength/2 - 7 , 0, 0])
					mat4.multiply(part, tmp, part);
				}
				else
				{
					mat4.fromTranslation(tmp, [-(dachsHundAnimLength/2 - 7) , 0, 0])
					mat4.multiply(part, tmp, part);
				}
				return part;
			}

			function cartoon(part, isTail, isPaw, pawX, pawY, isNeck, isHead)
			{
				var tailAnimRotationMatrix = mat4.create();
				var tmp = mat4.create();
				var tmp2 = mat4.create();

				if(isTail)
				{
					// Translate the part to the right position 
					mat4.fromTranslation(tmp, [0, 0, -9])
					mat4.multiply(part, tmp, part)

					// Calculate Rotation for the animation  and rotate the part
					mat4.fromRotation(tailAnimRotationMatrix, cartoonAnimTailAngle, [1, 0, 0]);
					mat4.multiply(part, tailAnimRotationMatrix, part)

					// Translate part to iniital position
					mat4.fromTranslation(tmp, [0, 0, 9])
					mat4.multiply(part, tmp, part)
					return part;
				}

				if(isPaw)
				{
					mat4.fromTranslation(tmp2, [-pawX, -pawY, 0])
					mat4.multiply(part, tmp2, part);
					mat4.fromScaling(tmp, [cartoonAnimPawScale, cartoonAnimPawScale, 1]);
					mat4.multiply(part, tmp, part);
					mat4.fromTranslation(tmp2, [pawX, pawY, 0])
					mat4.multiply(part, tmp2, part);
					return part;
				}

				if(isNeck)
				{
					mat4.fromTranslation(tmp2, [9, 0, -11.5])
					mat4.multiply(part, tmp2, part);
					mat4.fromScaling(tmp, [1, 1, cartoonNeckScale]);
					mat4.multiply(part, tmp, part);
					mat4.fromTranslation(tmp2, [-9, 0, 10 + cartoonNeckLength/2])
					mat4.multiply(part, tmp2, part);
					return part;
				}

				if(isHead)
				{
					mat4.fromTranslation(tmp, [0 , 0, -3 + cartoonNeckLength])
					mat4.multiply(part, tmp, part);
				}

		
				return part;
			}

			function handleMouseUp(event)
			{
				mouseDown = false;
			}

			function handleMainAnimations()
			{
				var isPlayDead = document.getElementById('playDead').checked;
				var isStaticWalk = document.getElementById('staticWalk').checked;
				var isNormalWalk = document.getElementById('normalWalk').checked;
				var isDachshund = document.getElementById('dachshund').checked;
				var isCartoon = document.getElementById('cartoon').checked;

				if(isPlayDead)
				{
					// If the angle is going to be bigger than 90 degrees change direction
					if(playDeadAnimX + playDeadAnimDirection * playDeadAnimStep <= -Math.PI/2 || playDeadAnimX + playDeadAnimDirection * playDeadAnimStep > 0)
						playDeadAnimDirection *= -1;

					// Calculate new rotation angle
					playDeadAnimX = playDeadAnimX + playDeadAnimDirection * playDeadAnimStep;
				}

				if(isStaticWalk)
				{
					// If the angle is going to be bigger than 90 degrees change direction
					if(Math.abs(staticWalkAnimY + staticWalkAnimDirection * staticWalkAnimStep) >= Math.PI/2)
						staticWalkAnimDirection *= -1;

					// Calculate new rotation angles
					staticWalkAnimY = staticWalkAnimY + staticWalkAnimDirection * staticWalkAnimStep;
				}
				if(isNormalWalk)
				{
					// If the angle is going to be bigger than 90 degrees change direction
					if(Math.abs(normalWalkAnimY + normalWalkAnimDirection * normalWalkAnimStep) >= Math.PI/2)
						normalWalkAnimDirection *= -1;

					// Calculate new rotation angles
					normalWalkAnimY = normalWalkAnimY + normalWalkAnimDirection * normalWalkAnimStep;
				}
				if(isDachshund)
				{
					// If the length of the body is going to be bigger than 2 times the initial length or less that the initial length change direction
					if(14 * dachsHundAnimScale > 28 || 14 * dachsHundAnimScale < 14)
						dachsHundAnimDirection *= -1;

					
					// Calculate new animation scale
					dachsHundAnimScale = dachsHundAnimScale + dachsHundAnimDirection*dachsHundAnimStep;
					dachsHundAnimLength = 14 * dachsHundAnimScale;
				}
					
				if(isCartoon)
				{
					// Calculate the angle for the tail rotation 
					cartoonAnimTailAngle = (cartoonAnimTailAngle + cartoonAnimTailStep) % (Math.PI * 2);

					// If the length of the body is going to be bigger than 2 times the initial length or less that the initial length change direction
					if(5 * cartoonAnimPawScale + cartoonAnimPawDirection*cartoonAnimPawStep > 8 || 5 * cartoonAnimPawScale + cartoonAnimPawDirection*cartoonAnimPawStep < 5)
						cartoonAnimPawDirection *= -1;

					// Calculate new animation scale
					cartoonAnimPawScale = cartoonAnimPawScale + cartoonAnimPawDirection*cartoonAnimPawStep;
					cartoonAnimPawLength = 5 * cartoonAnimPawScale;

					// If the length of the body is going to be bigger than 2 times the initial length or less that the initial length change direction
					if(3 * cartoonNeckScale + cartoonAnimNeckDirection*cartoonNeckStep > 6 || 3 * cartoonNeckScale + cartoonAnimNeckDirection*cartoonNeckStep < 3)
						cartoonAnimNeckDirection *= -1;

					// Calculate new animation scale
					cartoonNeckScale = cartoonNeckScale + cartoonAnimNeckDirection*cartoonNeckStep;
					cartoonNeckLength = 3 * cartoonNeckScale;
				}
			}

			function handleSimpleAnimations()
			{
				var isHead = document.getElementById('Head').checked;
				var isFLPaw = document.getElementById('FrontLeftPaw').checked;
				var isFRPaw = document.getElementById('FrontRightPaw').checked;
				var isTail = document.getElementById('Tail').checked;
				

				if(isHead)
				{
					// If the angle is going to be bigger than 90 degrees change direction
					if(Math.abs(headAnimZ + headAnimDirection * headAnimStep) >= Math.PI/2)
						headAnimDirection *= -1;

					// Calculate new rotation angle
					headAnimZ = headAnimZ + headAnimDirection * headAnimStep;
				}

				if(isTail)
				{
					// If the angle is going to be bigger than 90 degrees change direction
					if(Math.abs(tailAnimX + tailAnimDirection * tailAnimStep) >= Math.PI/2)
						tailAnimDirection *= -1;

					// Calculate new rotation angle
					tailAnimX = tailAnimX + tailAnimDirection * tailAnimStep;
				}

				if(isFLPaw)
				{
					// If the angle is going to be bigger than 90 degrees change direction
					if(FLPAnimY + FLPAnimDirection * FLPAnimStep <= -Math.PI/2 || FLPAnimY + FLPAnimDirection * FLPAnimStep > 0)
						FLPAnimDirection *= -1;

					// Calculate new rotation angle
					FLPAnimY = FLPAnimY + FLPAnimDirection * FLPAnimStep;
				}
				
				if(isFRPaw)
				{
					// If the angle is going to be bigger than 90 degrees change direction
					if(FRPAnimY + FRPAnimDirection * FRPAnimStep <= -Math.PI/2 || FRPAnimY + FRPAnimDirection * FRPAnimStep > 0)
						FRPAnimDirection *= -1;

					// Calculate new rotation angle
					FRPAnimY = FRPAnimY + FRPAnimDirection * FRPAnimStep;
				}
			}

			function initializeAnimationVars()
			{
				headAnimZ = 0;
				headAnimStep = 0.05;
				headAnimDirection = 1;

				tailAnimX = 0;
				tailAnimStep = 0.05;
				tailAnimDirection = 1;

				FLPAnimY = 0;
				FLPAnimStep = 0.05;
				FLPAnimDirection = 1;

				FRPAnimY = 0;
				FRPAnimStep = 0.05;
				FRPAnimDirection = 1;

				playDeadAnimX = 0;
				playDeadAnimStep = 0.05;
				playDeadAnimDirection = 1;

				staticWalkAnimY = 0;
				staticWalkAnimStep = 0.05;
				staticWalkAnimDirection = 1;

				normalWalkAnimY = 0;
				normalWalkAnimStep = 0.05;
				normalWalkAnimDirection = 1;

				dachsHundAnimLength = 14;
				dachsHundAnimStep = 0.05;
				dachsHundAnimDirection = 1;
				dachsHundAnimScale = 1;

				cartoonAnimPawStep = 0.03;
				cartoonAnimPawScale = 1;
				cartoonAnimPawLength = 5;
				cartoonAnimPawDirection = 1;
				cartoonAnimTailAngle = 0;
				cartoonAnimTailStep = 0.1;
				cartoonNeckLength = 3;
				cartoonAnimNeckDirection = 1;
				cartoonNeckStep = 0.05;
				cartoonNeckScale = 1;
			}

			function startAnim() 
			{
				if (!requestId)
				{
					mainAnimation = true;
					initializeAnimationVars()
					anim();
				}		
			}

			function anim() 
			{
				requestId = window.requestAnimationFrame(anim);

				if(mainAnimation)
					handleMainAnimations();

				redraw();
			}

			function stopAnim() 
			{
				window.cancelAnimationFrame(requestId);
				mainAnimation = false;
				requestId = 0;
			}
		</script>
	</head>
	<body onload="startup()">
		<div class="container-fluid style" style="margin-top: 2%; margin-left: 2%;">
			<div class="row align-items-center">
				<div class="col justify-content-start">
					<canvas id="myGLCanvas" >
					</canvas>
				</div>
				<div class="col align-middle">
					<div class="row justify-content-center mt-1">
						<h1 class="mt-3">Camera angle</h1>
					</div>
						
					<div class="row justify-content-center">
						<input type="number" min="0" id="cAngle" value="90">
					</div>

					<div class="row justify-content-center mt-1">
						<h1 class="mt-5">Movements</h1>
					</div>

					<div class="row justify-content-center">
						<div clas="col">
							<div class="form-check">
								<input class="form-check-input" type="checkbox" value="" id="Head">
								<label class="form-check-label" for="Head">Head</label>
							</div>
	
							<div class="form-check">
								<input class="form-check-input" type="checkbox" value="" id="FrontLeftPaw">
								<label class="form-check-label" for="FrontLeftPaw">Front Left Paw</label>
							</div>
	
							<div class="form-check">
								<input class="form-check-input" type="checkbox" value="" id="FrontRightPaw">
								<label class="form-check-label" for="FrontRightPaw">Front Right Paw</label>
							</div>
	
							<div class="form-check">
								<input class="form-check-input" type="checkbox" value="" id="Tail">
								<label class="form-check-label" for="Tail">Tail</label>
							</div>

							<div class="form-check">
								<input class="form-check-input" type="checkbox" value="" id="cHeight">
								<label class="form-check-label" for="cHeight">Camera height</label>
							</div>
						</div>
					</div>

					<div class="row justify-content-center mt-1">
						<h1 class="mt-5">Animations</h1>
					</div>

					<div class="row justify-content-center mt-1">
						<div class="col-2">
							<div>
								<input type="radio" id="playDead" name="anim" value="playDead" onclick="initializeAnimationVars()">
								<label for="Left">Play Dead</label>
							</div>	

							<div>
								<input type="radio" id="staticWalk" name="anim" value="staticWalk" onclick="initializeAnimationVars()">
								<label for="Bottom">Static Walk</label>
							</div>		
							
							<div>
								<input type="radio" id="normalWalk" name="anim" value="normalWalk" onclick="initializeAnimationVars()">
								<label for="Back">Normal Walk</label>
							</div>		
							
							<div>
								<input type="radio" id="dachshund" name="anim" value="dachshund" onclick="initializeAnimationVars()">
								<label for="Back">Dachshund</label>
							</div>		

							<div>
								<input type="radio" id="cartoon" name="anim" value="cartoon" onclick="initializeAnimationVars()">
								<label for="Back">Cartoon</label>
							</div>

							<div>
								<input type="radio" id="none" name="anim" value="none" onclick="initializeAnimationVars()">
								<label for="Back">None</label>
							</div>
						</div>
					</div>

					<div class="row justify-content-center mt-4">
						<button class="btn btn-secondary mr-5" onclick="startAnim()">Start</button>
						<button class="btn btn-secondary ml-4" onclick="stopAnim()">Stop</button>
					</div>
				</div>
			</div>
		</div>
	</body>
</html>